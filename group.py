#! /usr/bin/env python
# -*- coding: utf-8 -*-

import sys
import os
from glob import glob
from optparse import OptionParser, OptionGroup
import json

#globals
spectra = {}  #dictionary of all spectra with the groups to which they belong
i = 1         #group or component counter
j = 1         #spectra counter

def main():
  print("\n*******************************************************************************")
  print(  "* GCMStoolbox - a set of tools for GC-MS data analysis                        *")
  print(  "*   Author:  Wim Fremout, Royal Institute for Cultural Heritage (28 Nov 2016) *")
  print(  "*   Licence: GNU GPL version 3.0                                              *")
  print(  "*                                                                             *")
  print(  "* GROUP:                                                                      *")
  print(  "*   Search groups in a NIST search of a large dataset against itself          *")
  print(  "*                                                                             *")
  print(  "*******************************************************************************\n")

  shortdescr = ("Search for groups of the same mass spectra in a large dataset by using\n"
                "NIST search results (generated by MSpepsearch) of the dataset against\n"
                "itself. Search hits can be optionally reduced by applying a retention index\n"
                "window.")

  ### OPTIONPARSER
  
  usage = "usage: %prog [options] INFILE"
  parser = OptionParser(usage, version="%prog 0.1")
  parser.add_option("-v", "--verbose", help="Be very verbose",  action="store_true", dest="verbose", default=False)
  parser.add_option("-o", "--outfile", help="Output file name", action="store",      dest="outfile", type="string")
  parser.add_option("-r", "--ri",      help="Apply RI window (default [0]: no RI filter)",  action="store", dest="ri", type="float", default=0)
  parser.add_option("-R", help="Discard hits without RI",  action="store_true", dest="discard", default=False)
  parser.add_option("-m", "--match", help="Apply RI window (default [0]: no RI filter)", action="store", dest="minmf", type="int", default=0)
  parser.add_option("-n", "--reverse", help="Apply RI window (default [0]: no RI filter)", action="store", dest="minrmf", type="int", default=0)
  (options, args) = parser.parse_args()

  ### ARGUMENTS

  if options.verbose: print("Processing arguments")

  if len(args) == 0:
    exit()

  # make a list of input files
  inFiles = []
  for arg in args:
    inFiles.extend(glob(arg))
  inFiles = list(set(inFiles)) #remove duplicates
  for inFile in inFiles:
    if os.path.isdir(inFile):
      inFiles.remove(inFile)   #remove directories
    else:
      if options.verbose: print(" - input file: " + inFile)

  # number of inFiles; must not be 0
  numInFiles = len(inFiles)
  if numInFiles != 1:
    parser.error("There should be exactly one input file.")
    exit()
  else:
    inFile = inFiles[0]
    
  if options.outfile != None:
    outFile = options.outfile
  else:
    outFile = "groups.json"

  # read mspepsearch results and create the spectra dictionary (couples of "spectrum name : group number")
  #global spectra
  readmspepsearch(inFile, options.ri, options.discard, options.minmf, options.minrmf, options.verbose)
  
  print("Number of mass spectra: " + str(j - 1))
  print("Number of components:   " + str(i - 1))
  print("\n\n")
  
  # make output file
  handle = open(outFile, "w")
  handle.write(json.dumps(groupByComponent(), indent=2))
  handle.close()
  


def readmspepsearch(inFile, riwindow = 0, discard = False, minMF = 0, minRMF = 0, verbose = False):
  ### ITERATE THROUGH INFILE
  # and generate a dictionary of spectra
  print("\nProcessing file: " + inFile)
  
  global spectra, j
  hits = []     #list of (accepted) hits for each NIST search
  
  with open(inFile,'r') as handle:   #file handle closes itself 
    for line in handle: 
      if line.casefold().startswith('unknown'):
        # first process the previous hits list 
        if len(hits) > 0:
          if verbose: print(" - Unknown: " + unknown)
          processHits(hits, verbose)
        
        # reinit
        j = j + 1
        hits = []
        
        unknown = line.split(": ", 1)[1]
        unknown = unknown.split("Compound in Library Factor = ")[0]
        unknown = unknown.strip()
        
        if riwindow > 0:
          unknownRI = extractRI(unknown)
        else:
          unknownRI = 0
      
      elif line.casefold().startswith('hit'):
        # dissect the "hit" line
        line = line.split(": ", 1)[1]
        parts = line.split(">>; ")     # the possibility of having semicolons inside the sample name makes this more complex
        hit = parts[0].replace("<<", "").strip()
        
        if riwindow > 0:
          hitRI = extractRI(hit)
        else:
          hitRI = 0
        
        hitMF, hitRMF, temp = parts[2].split("; ", 2)
        hitMF = int(hitMF.replace("MF: ", "").strip())
        hitRMF = int(hitRMF.replace("RMF: ", "").strip())
        
        # selection based on RIwindow, minMF, minRMF 
        if (riwindow > 0) and (unknownRI > 0) and (hitRI > 0) and (unknownRI - abs(riwindow / 2) <= hitRI <= unknownRI + abs(riwindow / 2)):
          # RIwindow is given and both RI's are present: accept hit when RI falls within the window
          accept = True
        elif (riwindow > 0) and (not discard) and ((unknownRI == 0) or (hitRI == 0)):
          # RIwindow is given (without discard option) but at least one of the RI's is missing: accept anyway
          accept = True
        elif (riwindow == 0):
          # RIwindow is zero (= RI matching is disabled): accept
          accept = True
        else:
          accept = False
        
        if (minMF > 0) and (minMF > hitMF):
          accept = False
        
        if (minRMF > 0) and (minRMF > hitRMF):
          accept = False
          
        # add to hits (if the hit is accepted)
        if accept:
          hits.append(hit)
  
  #process the last unknown
  if len(hits) > 0:
    if verbose: print(" - Unknown: " + unknown)
    processHits(hits, verbose)



def extractRI(name):
  if "RI=" in name:
    ri = name.split("RI=", 1)[1]
    ri = ri.split(" ", 1)[0]
    ri = float(ri.strip())
  else:
    ri = 0
  return ri



      
def processHits(hits, verbose = False):
  global spectra
  global i
  
  foundgroups = []
  for hit in hits:
    if hit in spectra:
      if spectra[hit] not in foundgroups:
        foundgroups.append(spectra[hit])
  
  if len(foundgroups) == 0:
    group = i
    i = i + 1
    if verbose: print("   new component [C" + str(group) + "]")
  else:
    group = foundgroups[0]
    if verbose: print("   existing component [C" + str(group) + "]")
    if len(foundgroups) > 1:
      print ("   !! Components " + ', '.join(str(x) for x in foundgroups) + " may be identical: a spectrum was found that belongs to these groups.")

  for hit in hits:
    spectra[hit] = group
  
  
  
def groupByComponent(verbose = False):
  global spectra
  global i
  global j
  
  groups = {}
  for key, value in spectra.items():
    ri = extractRI(key)
    if value not in groups:
      # initialise the group
      groups[value] = {"spectra": [key], "count": 1, "minRI": ri, "maxRI": ri, "deltaRI": 0}
    else:
      # add spectrum to the group
      groups[value]["spectra"].append(key)
      groups[value]["count"] += 1
      if ri != 0:
        if (groups[value]["minRI"] == 0) or (groups[value]["minRI"] > ri):
          groups[value]["minRI"] = ri
        if (groups[value]["maxRI"] == 0) or (groups[value]["maxRI"] < ri):
          groups[value]["maxRI"] = ri
        groups[value]["deltaRI"] = groups[value]["maxRI"] - groups[value]["minRI"]
  
  return groups
  
  
    
if __name__ == "__main__":
  main()
          
